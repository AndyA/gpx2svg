#!/usr/bin/env python3

#   Copyright (c) 2012-2013 Tobias Leupold <tobias.leupold@web.de>
#
#   gpx2svg - Convert GPX formatted geodata to Scalable Vector Graphics (SVG)
#
#   This program is free software; you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by the Free
#   Software Foundation in version 2 of the License.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#   or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
#   for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

__version__ = '0.1.2'

import argparse
import sys
import math
from xml.dom.minidom import parse as parseXml

def parseGpx(gpxFile):

  """Get the latitude and longitude data of all track segments in a GPX file"""

  # Get the XML information
  try:
    gpx = parseXml(gpxFile)
  except IOError as error:
    print('Error while reading file: %s. Terminating.' %  error, file = sys.stderr)
    sys.exit(1)
  except:
    print('Error while parsing XML data:', file = sys.stderr)
    print(sys.exc_info(), file = sys.stderr)
    print('Terminating.', file = sys.stderr)
    sys.exit(1)

  # Iterate over all tracks, track segments and points

  gpsData = []

  for track in gpx.getElementsByTagName('trk'):

    for trackseg in track.getElementsByTagName('trkseg'):

      trackSegData = []

      for point in trackseg.getElementsByTagName('trkpt'):
        trackSegData.append((float(point.attributes['lon'].value), float(point.attributes['lat'].value)))

      # Leave out empty segments
      if(trackSegData != []):
        gpsData.append(trackSegData)

  return gpsData

def mercatorProjection(gpsData, meridian = 0, r = 6378135):

  """Do the mercator projection for a GPS dataset"""

  projectedData = []

  for segment in gpsData:

    projectedSegment = []

    for coord in segment:
      projectedSegment.append(mercator(coord, meridian, r))

    projectedData.append(projectedSegment)

  return(projectedData)

def mercator(coord, meridian, r):

  """Calculate the Mercator projection of a coordinate pair"""

  pi = 3.14159265
  meridian = meridian * pi / 180.0

  x = r * ((coord[0] * pi / 180.0) - meridian)
  y = r * math.log(math.tan((pi / 4.0) + ((coord[1] * pi / 180.0) / 2.0)))

  return((x, y))

def moveProjectedData(gpsData):

  """Move a dataset to 0,0 and return it with the resulting width and height"""

  # Find the minimum and maximum x and y coordinates

  minX = maxX = gpsData[0][0][0]
  minY = maxY = gpsData[0][0][1]

  for segment in gpsData:
    for coord in segment:
      if coord[0] < minX:
        minX = coord[0]
      if coord[0] > maxX:
        maxX = coord[0]
      if coord[1] < minY:
        minY = coord[1]
      if coord[1] > maxY:
        maxY = coord[1]

      # Move the GPS data to 0,0

  movedGpsData = []

  for segment in gpsData:

    movedSegment = []

    for coord in segment:
      movedSegment.append((coord[0] - minX, coord[1] - minY))

    movedGpsData.append(movedSegment)

  # Return the moved data and it's width and height
  return(movedGpsData, maxX - minX, maxY - minY)

def searchCircularSegments(gpsData):

  """Splits a GPS dataset to tracks that are circular and other tracks"""

  circularSegments = []
  straightSegments = []

  for segment in gpsData:
    if segment[0] == segment[len(segment) - 1]:
      circularSegments.append(segment)
    else:
      straightSegments.append(segment)

  return(circularSegments, straightSegments)

def combineSegmentPairs(gpsData):

  """Combine segment pairs to one bigger segment"""

  combinedData = []

  # Walk through the GPS data and search for segment pairs that end with the starting point of another track

  while len(gpsData) > 0:

    # Get one segment from the source GPS data
    firstTrackData = gpsData.pop()

    foundMatch = False

    # Try to find a matching segment
    for i in range(len(gpsData)):
      if firstTrackData[len(firstTrackData) - 1] == gpsData[i][0]:
        # There is a matching segment, so break here
        foundMatch = True
        break

    if foundMatch == True:
      # We found a pair of segments with one shared point, so pop the data of the second
      # segment from the source GPS data and create a new segment containing all data, but
      # without the overlapping point
      firstTrackData.pop()
      combinedData.append(firstTrackData + gpsData[i])
      gpsData.pop(i)
    else:
      # No segment with a shared point was found, so just append the data to the output
      combinedData.append(firstTrackData)

  return(searchCircularSegments(combinedData))

def combineSegments(gpsData):

  """Combine all segments of a GPS dataset that can be combined"""

  # Search for circular segments. We can't combine them with any other segment.
  circularSegments, remainingSegments = searchCircularSegments(gpsData)

  # Search for segments that can be combined

  while True:

    # Look how many tracks we have now
    segmentsBefore = len(remainingSegments)

    # Search for segments that can be combined
    newCircularSegments, remainingSegments = combineSegmentPairs(remainingSegments)

    # Add newly found circular segments to processedSegments -- they can't be used anymore
    circularSegments = circularSegments + newCircularSegments

    if segmentsBefore == len(remainingSegments):
      # combineSegmentPairs() did not reduce the number of tracks anymore,
      # so we can't combine more tracks and can stop here
      break

  return(circularSegments + remainingSegments)

def scaleCoords(coord, height, scale):
  """Return a scaled pair of coordinates"""
  return(coord[0] * scale, (coord[1] * -1 + height) * scale)

def createCoordString(segment, height, scale):

  """Create the coordinate part of an SVG path string from a GPS data segment"""

  coordString = ''

  for coord in segment:
    x, y = scaleCoords(coord, height, scale)
    coordString = coordString + ' ' + str(x) + ',' + str(y)

  return coordString

def createPathString(drawCommand):
  """Return a complete path element for a draw command string"""
  return '<path d="' + drawCommand + '" style="fill:none;stroke:black" />\n'

def writeSvgData(gpsData, width, height, maxPixels, dropSinglePoints, outfile):

  """Output the SVG data -- quick 'n' dirty, without messing around with dom stuff ;-)"""

  # Calculate the scale factor we need to fit the requested maximal output size
  if width <= maxPixels and height <= maxPixels:
    scale = 1
  elif width > height:
    scale = maxPixels / width
  else:
    scale = maxPixels / height

  # Open the requested output file or map to /dev/stdout
  if outfile != '/dev/stdout':
    fp = open(outfile, 'w')
  else:
    fp = sys.stdout

  # Header data
  fp.write('<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n')
  fp.write('<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"\n  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n')
  fp.write('<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="%spx" height="%spx">\n' % (width * scale, height * scale))

  # Process all track segments and generate ids and path drawing commands for them

  # First, we split the data to circular and straight segments
  circularSegments, straightSegments = searchCircularSegments(gpsData)

  realCircularSegments = []
  singlePoints = []

  for segment in circularSegments:

    # We can leave out the last point, because it's equal to the first one
    segment.pop()

    if len(segment) == 1:
      # It's a single point
      if dropSinglePoints == False:
        # We want to keep single points, so add it to singlePoints
        singlePoints.append(segment)
    else:
      realCircularSegments.append(segment)

  circularSegments = realCircularSegments

  # Draw single points if requested

  if len(singlePoints) > 0:

    fp.write('<g>\n')

    for segment in singlePoints:
      x, y = scaleCoords(segment[0], height, scale)
      fp.write('<circle cx="' + str(x) + '" cy="' + str(y) + '" r="0.5" style="stroke:none;fill:black"/>\n')

    fp.write('</g>\n')

  # Draw all circular segments

  if len(circularSegments) > 0:

    fp.write('<g>\n')

    for segment in circularSegments:
      fp.write(createPathString('M' + createCoordString(segment, height, scale) + ' Z'))

    fp.write('</g>\n')

  # Draw all un-closed paths

  if len(straightSegments) > 0:

    fp.write('<g>\n')

    for segment in straightSegments:
      d = 'M' + createCoordString(segment, height, scale)
      fp.write(createPathString('M' + createCoordString(segment, height, scale)))

    fp.write('</g>\n')

  # Close the XML
  fp.write('</svg>\n')

  # Close the file if necessary
  if fp != sys.stdout:
    fp.close()

def main():

  # Setup the command line argument parser

  cmdArgParser = argparse.ArgumentParser(
    description = 'Convert GPX formatted geodata to Scalable Vector Graphics (SVG)',
    epilog = 'gpx2svg %s - http://nasauber.de/opensource/gpx2svg/' % __version__
  )

  cmdArgParser.add_argument(
    '-i', metavar = 'FILE', nargs = '?', type = str, default = '/dev/stdin',
    help = 'GPX input file (default: read from STDIN)'
  )
  cmdArgParser.add_argument(
    '-o', metavar = 'FILE', nargs = '?', type = str, default = '/dev/stdout',
    help = 'SVG output file (default: write to STDOUT)'
  )
  cmdArgParser.add_argument(
    '-m', metavar = 'PIXELS', nargs = '?', type = int, default = 3000,
    help = 'Maximum width or height of the SVG output in pixels (default: 3000)'
  )
  cmdArgParser.add_argument(
    '-d', action = 'store_true',
    help = 'Drop single points (default: draw a circle with 1px diameter)'
  )
  cmdArgParser.add_argument(
    '-r', action = 'store_true',
    help = '"Raw" conversion: Create one SVG path per track segment, don\'t try to combine paths that end with the starting point of another path'
  )

  # Get the given arguments
  cmdArgs = cmdArgParser.parse_args()

  # Map "-" to STDIN or STDOUT
  if cmdArgs.i == '-':
    cmdArgs.i = '/dev/stdin'
  if cmdArgs.o == '-':
    cmdArgs.o = '/dev/stdout'

  # Get the latitude and longitude data from the given GPX file or STDIN
  gpsData = parseGpx(cmdArgs.i)

  # Check if we actually _have_ data
  if gpsData == []:
    print('No data to convert. Terminating.', file = sys.stderr)
    sys.exit(1)

  # Try to combine all track segments that can be combined if not requested otherwise
  if not cmdArgs.r:
    gpsData = combineSegments(gpsData)

  # Do the Mercator projection of the GPS data
  gpsData = mercatorProjection(gpsData)

  # Move the projected data to the 0,0 origin of a cartesial coordinate system
  # and get the raw width and height of the resulting vector data
  gpsData, width, height = moveProjectedData(gpsData)

  # Write the resulting SVG data to the requested output file or STDOUT
  writeSvgData(gpsData, width, height, cmdArgs.m, cmdArgs.d, cmdArgs.o)

if __name__ == '__main__':
  main()

